document.addEventListener("DOMContentLoaded", () => {
  const CSRF_TOKEN = document.body.getAttribute('data-csrf-token');

  const audio = document.getElementById('audio');
  const playBtn = document.getElementById('playBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const repeatBtn = document.getElementById('repeatBtn');
  const volumeControl = document.getElementById('volume');
  const currentTimeDisplay = document.getElementById('current-time');
  const durationDisplay = document.getElementById('duration');
  const visualizer = document.getElementById('visualizer');
  const progressBar = document.getElementById('progress-bar');
  const statusDisplay = document.getElementById('status');
  const bitrateDisplay = document.getElementById('bitrate');
  const currentYear = document.getElementById('current-year');
  const currentSongDisplay = document.getElementById('current-song');
  const currentArtistDisplay = document.getElementById('current-artist');
  const coverArt = document.getElementById('coverArt');
  const playlistElement = document.getElementById('playlist');
  const refreshBtn = document.getElementById('refreshBtn');
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadModal = document.getElementById('uploadModal');
  const cancelBtn = document.getElementById('cancelBtn');
  const cancelUploadBtn = document.getElementById('cancelUploadBtn');
  const uploadForm = document.getElementById('uploadForm');
  const coverInput = document.getElementById('coverInput');
  const coverFileName = document.getElementById('coverFileName');
  const coverPreview = document.getElementById('coverPreview');
  const coverPreviewImg = document.getElementById('coverPreviewImg');
  const songInput = document.getElementById('songInput');
  const songFileName = document.getElementById('songFileName');
  const toast = document.getElementById('toast');
  const miniPlayer = document.getElementById('miniPlayer');

  let playlist = [];
  let currentSongIndex = -1;
  let isPlaying = false;
  let isShuffled = false;
  let isRepeatOn = false;
  let originalPlaylistOrder = [];
  let audioContext, analyser, dataArray;

  currentYear.textContent = new Date().getFullYear();

  const barCount = 50;
  for (let i = 0; i < barCount; i++) {
    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.height = '10px';
    visualizer.appendChild(bar);
  }
  const bars = document.querySelectorAll('.bar');

  function formatTime(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    return [h.toString().padStart(2, '0'), m.toString().padStart(2, '0'), s.toString().padStart(2, '0')].join(':');
  }

  function updateTimeDisplays() {
    currentTimeDisplay.textContent = formatTime(audio.currentTime);
    if (audio.duration) {
      durationDisplay.textContent = formatTime(audio.duration);
      const progress = (audio.currentTime / audio.duration) * 100;
      progressBar.style.width = `${progress}%`;
    }
  }

  function setupAudioContext() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      const source = audioContext.createMediaElementSource(audio);
      source.connect(analyser);
      analyser.connect(audioContext.destination);
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      statusDisplay.textContent = "Playing";
      updateVisualizer();
    } catch (e) {
      console.error("AudioContext setup error:", e);
      statusDisplay.textContent = "Error initializing audio playback: " + e.message;
      showNotification("Audio system error. Please refresh.", true);
    }
  }

  function updateVisualizer() {
    if (!analyser) return;
    analyser.getByteFrequencyData(dataArray);
    const segmentSize = Math.floor(dataArray.length / barCount);
    for (let i = 0; i < barCount; i++) {
      let sum = 0;
      for (let j = 0; j < segmentSize; j++) {
        sum += dataArray[i * segmentSize + j];
      }
      const average = sum / segmentSize;
      bars[i].style.height = `${average / 2}px`;
    }
    requestAnimationFrame(updateVisualizer);
  }

  async function fetchPlaylist() {
    playlistElement.innerHTML = `
      <li class="text-center py-10">
        <div class="spinner mx-auto mb-2"></div>
        <p>Loading playlist...</p>
      </li>
    `;
    try {
      const response = await fetch('/?action=getPlaylist'); // Adjusted URL
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Network response was not ok: ${response.status} ${response.statusText} - ${errorText}`);
      }
      const contentType = response.headers.get("content-type");
      if (!contentType || !contentType.includes("application/json")) {
          const responseText = await response.text();
          console.error("Received non-JSON response:", responseText);
          throw new TypeError("Oops, we haven't got JSON! Response: " + responseText.substring(0, 100) + "...");
      }
      const responseData = await response.json();

      if (responseData.status === 'success' && responseData.data && Array.isArray(responseData.data.songs)) {
        playlist = responseData.data.songs;
        originalPlaylistOrder = [...playlist];
        updatePlaylistDisplay();
        showNotification("Playlist loaded successfully!");
      } else if (responseData.status === 'error' && responseData.message) {
        console.error("API error fetching playlist:", responseData.message);
        playlistElement.innerHTML = `<li class="text-center py-10 text-red-400"><i class="fas fa-exclamation-triangle text-3xl mb-2"></i><p>Error loading playlist: ${responseData.message}</p></li>`;
        showNotification(`Error: ${responseData.message}`, true);
      } else {
        console.error("Invalid or unexpected JSON structure from getPlaylist:", responseData);
        playlistElement.innerHTML = `<li class="text-center py-10 text-red-400"><i class="fas fa-exclamation-triangle text-3xl mb-2"></i><p>Failed to load playlist. Unexpected server response.</p></li>`;
        showNotification("Failed to load playlist: Unexpected response", true);
      }
    } catch (error) {
      console.error("Critical error fetching playlist:", error);
      playlistElement.innerHTML = `<li class="text-center py-10 text-red-400"><i class="fas fa-exclamation-triangle text-3xl mb-2"></i><p>Error loading playlist. Please check connection and try again.</p></li>`;
      showNotification("Network error or critical issue loading playlist.", true);
    }
  }

  function updatePlaylistDisplay() {
    if (playlist.length === 0) {
      playlistElement.innerHTML = `
        <li class="text-center py-10 text-white/50">
          <i class="fas fa-music text-3xl mb-2"></i>
          <p>No songs in playlist</p>
        </li>
      `;
      return;
    }
    playlistElement.innerHTML = playlist.map((song, index) => `
      <li class="song-item bg-white/5 p-3 rounded-lg cursor-pointer hover:bg-white/10 transition-all ${currentSongIndex === index ? 'current-song' : ''}"
           onclick="playSong(${index})">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-md overflow-hidden ${song.cover ? '' : 'default-cover'}" ${!song.cover ? 'aria-label="Default cover art icon"' : ''}>
            ${song.cover ?
              `<img src="/${song.cover}" class="w-full h-full object-cover" alt="Cover art for ${song.title || 'song'}">` : // Adjusted path for cover
              `<i class="fas fa-music w-full h-full flex items-center justify-center" aria-hidden="true"></i>`}
          </div>
          <div class="flex-1 min-w-0">
            <p class="font-medium truncate">${song.title}</p>
            <p class="text-sm text-white/70 truncate">${song.artist}</p>
          </div>
          <span class="text-xs text-white/50">${formatTime(song.duration || 0)}</span>
        </div>
      </li>
    `).join('');
  }

  function toggleShuffle() {
    isShuffled = !isShuffled;
    if (isShuffled) {
      if (originalPlaylistOrder.length === 0) {
        originalPlaylistOrder = [...playlist];
      }
      for (let i = playlist.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
      }
      if (currentSongIndex !== -1) {
        const currentSongData = originalPlaylistOrder[currentSongIndex]; // Find based on original index if possible
         const newIdx = playlist.findIndex(s => s.id === currentSongData.id);
         if(newIdx !== -1) currentSongIndex = newIdx;
      }
      shuffleBtn.classList.add('control-active');
      showNotification("Shuffle mode on");
    } else {
      const currentSongData = (currentSongIndex !== -1 && currentSongIndex < playlist.length) ? playlist[currentSongIndex] : null;
      playlist = [...originalPlaylistOrder];
      if (currentSongData) {
         const newIdx = playlist.findIndex(s => s.id === currentSongData.id);
         if(newIdx !== -1) currentSongIndex = newIdx;
      }
      shuffleBtn.classList.remove('control-active');
      showNotification("Shuffle mode off");
    }
    updatePlaylistDisplay();
  }

  function toggleRepeat() {
    isRepeatOn = !isRepeatOn;
    repeatBtn.classList.toggle('control-active', isRepeatOn);
    showNotification(`Repeat mode ${isRepeatOn ? 'on' : 'off'}`);
  }

  async function playSong(index) {
    if (index < 0 || index >= playlist.length) return;
    currentSongIndex = index;
    const song = playlist[index];
    currentSongDisplay.textContent = song.title;
    currentArtistDisplay.textContent = song.artist;
    if (song.title.length > 20) {
      currentSongDisplay.innerHTML = `<span class="marquee">${song.title}</span>`;
    } else {
      currentSongDisplay.textContent = song.title;
    }
    if (song.cover) {
      coverArt.innerHTML = `<img src="/${song.cover}" class="w-full h-full object-cover" alt="Cover art for ${song.title}">`; // Adjusted path for cover
      coverArt.removeAttribute('aria-label');
    } else {
      coverArt.innerHTML = `<i class="fas fa-music text-xl text-purple-400" aria-hidden="true"></i>`;
      coverArt.setAttribute('aria-label', 'Default cover art icon');
    }
    audio.src = `/${song.file}`; // Adjusted path for song file
    audio.load();
    try {
      await audio.play();
      playBtn.innerHTML = '<i class="fas fa-pause text-xl"></i>';
      playBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
      playBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
      isPlaying = true;
      statusDisplay.textContent = "Playing";
      miniPlayer.innerHTML = '<i class="fas fa-pause"></i>';
      miniPlayer.classList.remove('hidden');
      if (!audioContext) {
        setupAudioContext();
      }
      showNotification(`Now playing: ${song.title}`);
      setupMediaSession(song);
    } catch (error) {
      console.error("Error playing song:", song.title, error);
      showNotification(`Error playing ${song.title}: ${error.message}`, true);
      statusDisplay.textContent = "Error playing song";
    }
  }

  async function togglePlayPause() {
    if (playlist.length === 0) {
      showNotification('No songs in playlist', true);
      return;
    }
    if (currentSongIndex === -1) {
      await playSong(0);
      return;
    }
    if (audio.paused) {
      try {
        await audio.play();
        playBtn.innerHTML = '<i class="fas fa-pause text-xl"></i>';
        playBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
        playBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
        isPlaying = true;
        statusDisplay.textContent = "Playing";
        miniPlayer.innerHTML = '<i class="fas fa-pause"></i>';
        if (!audioContext) {
          setupAudioContext();
        }
      } catch (error) {
        console.error("Play error:", error);
        showNotification('Click anywhere to play', true);
      }
    } else {
      audio.pause();
      playBtn.innerHTML = '<i class="fas fa-play text-xl"></i>';
      playBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
      playBtn.classList.add('bg-green-600', 'hover:bg-green-700');
      isPlaying = false;
      statusDisplay.textContent = "Paused";
      miniPlayer.innerHTML = '<i class="fas fa-play"></i>';
    }
  }

  function prevSong() {
    if (playlist.length === 0) return;
    let newIndex = currentSongIndex - 1;
    if (newIndex < 0) newIndex = playlist.length - 1;
    playSong(newIndex);
  }

  function nextSong() {
    if (playlist.length === 0) return;
    if (isRepeatOn) {
      audio.currentTime = 0;
      audio.play().catch(error => { // Add catch here too
         console.error("Error re-playing song:", error);
         showNotification(`Error playing: ${error.message}`, true);
      });
      return;
    }
    let newIndex = currentSongIndex + 1;
    if (newIndex >= playlist.length) newIndex = 0;
    playSong(newIndex);
  }

  function showNotification(message, isError = false) {
    toast.textContent = message;
    // Ensure correct classes are applied for color based on error or success
    toast.className = 'fixed bottom-16 left-1/2 transform -translate-x-1/2 p-4 rounded-lg text-white z-50 transition-all duration-300 ease-in-out';
    if (isError) {
      toast.classList.add('bg-red-500');
    } else {
      toast.classList.add('bg-green-500');
    }
    toast.classList.add('show'); // Make it visible

    clearTimeout(toast.timeoutId);
    toast.timeoutId = setTimeout(() => {
      toast.classList.remove('show');
      // Reset classes after hiding to ensure correct color next time
      toast.className = 'fixed bottom-16 left-1/2 transform -translate-x-1/2 p-4 rounded-lg text-white z-50 transition-all duration-300 ease-in-out';
    }, 3000);
  }

  playBtn.addEventListener('click', togglePlayPause);
  prevBtn.addEventListener('click', prevSong);
  nextBtn.addEventListener('click', nextSong);
  shuffleBtn.addEventListener('click', toggleShuffle);
  repeatBtn.addEventListener('click', toggleRepeat);

  volumeControl.addEventListener('input', () => {
    audio.volume = volumeControl.value;
  });

  progressBar.parentElement.addEventListener('click', (e) => {
    if (!audio.duration) return;
    const rect = progressBar.parentElement.getBoundingClientRect(); // Use parent for rect
    const pos = (e.clientX - rect.left) / rect.width;
    audio.currentTime = pos * audio.duration;
  });

  audio.addEventListener('loadedmetadata', updateTimeDisplays);
  audio.addEventListener('timeupdate', updateTimeDisplays);
  audio.addEventListener('ended', () => {
    if (isRepeatOn) {
      audio.currentTime = 0;
      audio.play().catch(error => {
         console.error("Error re-playing song on end:", error);
         showNotification(`Error playing: ${error.message}`, true);
      });
    } else {
      nextSong();
    }
  });
  audio.addEventListener('error', (e) => {
    console.error("Audio Error:", e);
    statusDisplay.textContent = "Error loading audio";
    showNotification("Error loading audio file. It might be corrupt or unsupported.", true);
  });

  refreshBtn.addEventListener('click', async () => {
    refreshBtn.innerHTML = '<i class="fas fa-sync-alt animate-spin"></i>';
    await fetchPlaylist();
    refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
  });

  uploadBtn.addEventListener('click', () => {
    if (uploadModal) uploadModal.style.display = 'flex';
  });
  cancelBtn.addEventListener('click', () => {
    if (uploadModal) uploadModal.style.display = 'none';
  });
  cancelUploadBtn.addEventListener('click', () => {
    if (uploadModal) uploadModal.style.display = 'none';
  });

  coverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    coverFileName.textContent = file.name;
    coverPreview.classList.remove('hidden');
    const reader = new FileReader();
    reader.onload = (event) => {
      coverPreviewImg.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });

  songInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    songFileName.textContent = file.name;
  });

  uploadForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = '<div class="spinner mr-2"></div> Uploading...';
    submitBtn.disabled = true;
    const formData = new FormData(e.target);
    if (CSRF_TOKEN) {
        formData.append('csrf_token', CSRF_TOKEN);
    } else {
        console.error('CSRF_TOKEN is not available from body data attribute.');
        showNotification('A required security token is missing. Please refresh the page and ensure JavaScript can access it.', true);
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
        return;
    }

    try {
      const response = await fetch('/?action=uploadSong', { // Adjusted URL
        method: 'POST',
        body: formData
      });
      const contentType = response.headers.get("content-type");
      if (!contentType || !contentType.includes("application/json")) {
          const responseText = await response.text();
          console.error("Received non-JSON response from upload:", responseText);
          throw new TypeError("Oops, we haven't got JSON from upload! Response: " + responseText.substring(0,100) + "...");
      }
      const result = await response.json();

      if (result.status === 'success') {
        await fetchPlaylist();
        if (uploadModal) uploadModal.style.display = 'none';
        uploadForm.reset();
        coverPreview.classList.add('hidden');
        coverPreviewImg.src = '';
        coverFileName.textContent = 'Choose cover image';
        songFileName.textContent = 'Choose MP3 file';
        showNotification(result.message || 'Song uploaded successfully!');
      } else {
        showNotification(result.message || 'Upload failed. Please try again.', true);
      }
    } catch (error) {
      console.error("Upload error:", error);
      showNotification('Upload failed: Network error or server issue. ' + error.message, true);
    } finally {
      submitBtn.innerHTML = originalText;
      submitBtn.disabled = false;
    }
  });

  function setupMediaSession(song) {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: song.title,
        artist: song.artist,
        album: 'Local Radio', // You can customize this
        artwork: song.cover ? [{ src: `/${song.cover}` }] : [] // Adjusted path for cover
      });

      navigator.mediaSession.setActionHandler('play', togglePlayPause);
      navigator.mediaSession.setActionHandler('pause', togglePlayPause);
      navigator.mediaSession.setActionHandler('previoustrack', prevSong);
      navigator.mediaSession.setActionHandler('nexttrack', nextSong);
      // Add more handlers as needed: seekbackward, seekforward, etc.
    }
  }

  miniPlayer.addEventListener('click', () => {
    // Attempt to find the main player container to scroll to.
    // This assumes the player container is identifiable, e.g., by being the parent of #audio
    const playerContainer = document.querySelector('.w-full.max-w-2xl.bg-gray-800');
    if (playerContainer) {
        playerContainer.scrollIntoView({ behavior: 'smooth' });
    }
  });

  fetchPlaylist();
  window.playSong = playSong; // Make it globally accessible if needed for inline onclick attributes
});
